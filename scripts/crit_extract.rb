#!/usr/bin/env ruby
# scripts/crit_extract.rb
# Extract concise Markdown tables from Criterion outputs under target/criterion.
#
# Usage:
#   ruby scripts/crit_extract.rb            # prints Markdown to stdout
#   ruby scripts/crit_extract.rb --group banded_swa_soa
#   ruby scripts/crit_extract.rb --write PERFORMANCE.md  # append to file
#
# Notes:
# - Designed for Criterion 0.5 directory layout:
#   target/criterion/<group>/<bench>/new/estimates.json
# - We read mean.point_estimate (nanoseconds) and format as µs/ms as appropriate.
# - We do not compute throughput; benches that used Throughput::Bytes can be
#   interpreted by their bench names (e.g., i8_w32_len128_band20).

require 'json'
require 'time'

CRIT_DIR = File.join('target', 'criterion')

def human_time_ns(ns)
  return sprintf('%.3f ns', ns)   if ns < 1_000
  return sprintf('%.3f µs', ns/1_000.0) if ns < 1_000_000
  return sprintf('%.3f ms', ns/1_000_000.0) if ns < 1_000_000_000
  sprintf('%.3f s', ns/1_000_000_000.0)
end

def collect(group_filter: nil)
  entries = {}
  Dir.glob(File.join(CRIT_DIR, '**', 'new', 'estimates.json')).each do |path|
    parts = path.split(File::SEPARATOR)
    # .../target/criterion/<group>/<bench>/new/estimates.json
    idx = parts.index('criterion')
    next unless idx
    group = parts[idx + 1]
    bench = parts[idx + 2]
    next if group.nil? || bench.nil?
    next if group_filter && group != group_filter
    json = JSON.parse(File.read(path)) rescue nil
    next unless json && json['mean'] && json['mean']['point_estimate']
    mean_ns = json['mean']['point_estimate'].to_f
    (entries[group] ||= []) << { name: bench, mean_ns: mean_ns }
  end
  entries
end

def format_markdown(entries)
  ts = Time.now.utc.iso8601
  out = []
  out << "<!-- Generated by scripts/crit_extract.rb at #{ts} UTC -->"
  entries.keys.sort.each do |group|
    out << "\n### #{group}"
    out << "\n| benchmark | mean time |"
    out << "|---|---:|"
    entries[group].sort_by { |e| e[:name] }.each do |e|
      out << "| #{e[:name]} | #{human_time_ns(e[:mean_ns])} |"
    end
  end
  out.join("\n")
end

group = nil
write_path = nil
ARGV.each_with_index do |arg, i|
  case arg
  when '--group'
    group = ARGV[i+1]
  when '--write'
    write_path = ARGV[i+1]
  end
end

entries = collect(group_filter: group)
md = format_markdown(entries)

if write_path
  File.open(write_path, 'a') { |f| f.puts("\n\n## Criterion summary\n\n#{md}") }
else
  puts md
end
